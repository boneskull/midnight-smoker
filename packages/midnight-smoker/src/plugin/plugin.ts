import {z} from 'zod';
import {customSchema, zNonEmptyString} from '../schema-util';
import {PluginAPI} from './plugin-api';

/**
 * A function which receives a {@link PluginAPI} and uses it to define the
 * plugin.
 */
export type PluginFactory = (api: Readonly<PluginAPI>) => void | Promise<void>;

const zPluginFactory = z
  .custom<PluginFactory>(
    (value) => typeof value === 'function',
    'Must be a `void` or `async void` function accepting a `PluginAPI` argument',
  )
  .describe(
    'A `void` or `async void` function accepting a `PluginAPI` argument',
  );

/**
 * A plugin's default export (ESM) or the `module.exports` object (CJS).
 *
 * The default export may also just be a {@link PluginFactory}.
 *
 * @see {@link Plugin}
 */
export interface PluginObject {
  /**
   * This could be a named export `plugin` _or_ `exports.plugin`.
   */
  plugin: PluginFactory;
  name?: string;
  description?: string;
}

const zPluginObject = customSchema<PluginObject>(
  z
    .object({
      plugin: zPluginFactory,
      name: zNonEmptyString.optional(),
      description: zNonEmptyString.optional(),
    })
    .describe(
      'An object with a "plugin" property and optionally a name and description',
    ),
);

const zNormalizedPluginFactory = zPluginFactory
  .transform((value) => ({
    plugin: value,
  }))
  .pipe(zPluginObject)
  .describe('A normalized PluginFactory');

/**
 * {@link z.preprocess} is good here since we don't really care about calling out
 * the `default` named export as generated by Babel.
 */
export const zPlugin = z
  .preprocess(
    (value) =>
      value && typeof value === 'object' && 'default' in value
        ? value.default
        : value,
    zPluginObject.or(zNormalizedPluginFactory),
  )
  .pipe(zPluginObject)
  .describe('The plugin entry point');

/**
 * The shape a plugin entry point can assume. A module exporting a named
 * `plugin` {@link PluginFactory}, or the default export being a
 * {@link PluginFactory}.
 */
export type Plugin = z.infer<typeof zPlugin>;
